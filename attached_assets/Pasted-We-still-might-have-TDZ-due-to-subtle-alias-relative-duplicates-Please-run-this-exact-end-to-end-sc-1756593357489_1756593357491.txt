We still might have TDZ due to subtle alias/relative duplicates. Please run this exact end-to-end script to do a path-aware scan (not simple greps), report conflicts, and optionally normalize them:

set -e

# 0) Vars
SRC_DIR="client/src"
REPORT_DIR="tools/import-scan"
mkdir -p "$REPORT_DIR"

# 1) Create a Node script that resolves imports to canonical module keys
cat > "$REPORT_DIR/scan-imports.mjs" << 'EOF'
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '../../');
const SRC_DIR = path.join(projectRoot, 'client', 'src');

const exts = ['.ts','.tsx','.js','.jsx','.mjs','.mts','.cjs'];
const indexCandidates = exts.map(e => 'index'+e);

function readFileSafe(p) {
  try { return fs.readFileSync(p, 'utf8'); } catch { return null; }
}

function* walk(dir) {
  const ents = fs.readdirSync(dir, {withFileTypes:true});
  for (const e of ents) {
    const p = path.join(dir, e.name);
    if (e.isDirectory()) {
      yield* walk(p);
    } else if (/\.(ts|tsx|js|jsx|mjs|mts|cjs)$/.test(e.name)) {
      yield p;
    }
  }
}

function resolveRelative(importer, spec) {
  // Resolve like Node would, checking file or directory w/ index
  let p = path.resolve(path.dirname(importer), spec);

  // If file exists as-is, keep; else try appending extensions
  if (fs.existsSync(p) && fs.statSync(p).isFile()) return p;

  for (const e of exts) {
    if (fs.existsSync(p+e)) return p+e;
  }
  // If it's a directory, try index.*
  if (fs.existsSync(p) && fs.statSync(p).isDirectory()) {
    for (const idx of indexCandidates) {
      const cand = path.join(p, idx);
      if (fs.existsSync(cand)) return cand;
    }
  }
  return null;
}

function aliasToAbs(spec) {
  // Treat "@/x/y" as <SRC_DIR>/x/y
  const rel = spec.slice(2); // strip "@/‚Äù
  const abs = path.join(SRC_DIR, rel);
  if (fs.existsSync(abs) && fs.statSync(abs).isFile()) return abs;
  for (const e of exts) {
    if (fs.existsSync(abs+e)) return abs+e;
  }
  if (fs.existsSync(abs) && fs.statSync(abs).isDirectory()) {
    for (const idx of indexCandidates) {
      const cand = path.join(abs, idx);
      if (fs.existsSync(cand)) return cand;
    }
  }
  return null;
}

function toModuleKey(absPath) {
  // Create a canonical key like "features/auth/useAuth"
  let rel = path.relative(SRC_DIR, absPath).replace(/\\/g, '/');
  for (const e of exts) {
    if (rel.endsWith(e)) rel = rel.slice(0, -e.length);
  }
  if (rel.endsWith('/index')) rel = rel.slice(0, -('/index'.length));
  return rel;
}

const importRE = /^\s*import\s+(?:type\s+)?(?:.+?)\s+from\s+['"](.+?)['"]/mg;
const results = [];

for (const file of walk(SRC_DIR)) {
  const src = readFileSafe(file);
  if (!src) continue;
  let m;
  while ((m = importRE.exec(src)) !== null) {
    const spec = m[1];
    let kind = null, abs = null;

    if (spec.startsWith('@/')) {
      kind = 'alias';
      abs = aliasToAbs(spec);
    } else if (spec.startsWith('./') || spec.startsWith('../')) {
      kind = 'relative';
      abs = resolveRelative(file, spec);
    } else {
      continue; // package import
    }

    if (!abs) continue;
    const key = toModuleKey(abs);
    results.push({ importer: path.relative(projectRoot, file).replace(/\\/g,'/'), spec, kind, abs, key });
  }
}

fs.writeFileSync(path.join(__dirname, 'imports.json'), JSON.stringify(results, null, 2));
const byKey = new Map();
for (const r of results) {
  if (!byKey.has(r.key)) byKey.set(r.key, []);
  byKey.get(r.key).push(r);
}

const conflicts = [];
for (const [key, arr] of byKey.entries()) {
  const kinds = new Set(arr.map(a => a.kind));
  if (kinds.has('alias') && kinds.has('relative')) {
    conflicts.push({
      module_key: key,
      alias_importers: [...new Set(arr.filter(a=>a.kind==='alias').map(a=>a.importer))].sort(),
      relative_importers: [...new Set(arr.filter(a=>a.kind==='relative').map(a=>a.importer))].sort()
    });
  }
}

fs.writeFileSync(path.join(__dirname, 'conflicts.json'), JSON.stringify(conflicts, null, 2));
console.log('=== Mixed alias vs relative imports (conflicts) ===');
if (conflicts.length === 0) {
  console.log('None üéâ');
} else {
  for (const c of conflicts) {
    console.log(`‚Ä¢ ${c.module_key}`);
    console.log(`  alias in:    ${c.alias_importers.length}`);
    console.log(`  relative in: ${c.relative_importers.length}`);
  }
  console.log(`\nTotal conflicts: ${conflicts.length}`);
}
EOF

# 2) Run the scanner
node "$REPORT_DIR/scan-imports.mjs"

echo
echo "Artifacts written to:"
echo " - $REPORT_DIR/imports.json"
echo " - $REPORT_DIR/conflicts.json"

# 3) Show conflicts.json for quick visibility
echo
echo "=== conflicts.json (first 2000 chars) ==="
python - << 'PY'
import json, sys, textwrap
p="tools/import-scan/conflicts.json"
try:
    j=json.load(open(p))
    s=json.dumps(j, indent=2)
    print(s[:2000] + ('...' if len(s)>2000 else ''))
except Exception as e:
    print("Could not read", p, e)
PY

# 4) OPTIONAL: auto-fix relative -> alias for conflicted modules only
#    This avoids touching unrelated files/icons.
cat > "$REPORT_DIR/apply-fixes.mjs" << 'EOF'
import fs from 'fs';
import path from 'path';

const projectRoot = path.resolve(process.cwd());
const SRC_DIR = path.join(projectRoot, 'client', 'src');

const conflicts = JSON.parse(fs.readFileSync('tools/import-scan/conflicts.json','utf8'));
if (!Array.isArray(conflicts) || conflicts.length === 0) {
  console.log('No conflicts to fix.');
  process.exit(0);
}

function* walk(dir) {
  const ents = fs.readdirSync(dir, {withFileTypes:true});
  for (const e of ents) {
    const p = path.join(dir, e.name);
    if (e.isDirectory()) yield* walk(p);
    else if (/\.(ts|tsx|js|jsx|mjs|mts|cjs)$/.test(e.name)) yield p;
  }
}

const importLineRE = /(^\s*import\s+(?:type\s+)?(?:.+?)\s+from\s+)(['"])(.+?)\2(.*;?\s*)$/;
const keys = new Set(conflicts.map(c => c.module_key));

function candidateAliasForKey(key) {
  // produce "@/key"
  return '@/' + key;
}

let changedFiles = 0;

for (const file of walk(SRC_DIR)) {
  const orig = fs.readFileSync(file, 'utf8');
  const lines = orig.split('\n');
  let touched = false;

  const newLines = lines.map(line => {
    const m = importLineRE.exec(line);
    if (!m) return line;
    const spec = m[3];
    if (!(spec.startsWith('./') || spec.startsWith('../'))) return line; // only rewrite relative

    // Construct a rough module_key for this relative import file by resolving path
    const importerDir = path.dirname(file);
    let abs = path.resolve(importerDir, spec);
    const exts = ['.ts','.tsx','.js','.jsx','.mjs','.mts','.cjs'];
    const indexCandidates = exts.map(e => 'index'+e);

    if (fs.existsSync(abs) && fs.statSync(abs).isDirectory()) {
      for (const idx of indexCandidates) {
        const cand = path.join(abs, idx);
        if (fs.existsSync(cand)) { abs = cand; break; }
      }
    } else if (!fs.existsSync(abs)) {
      for (const e of exts) {
        if (fs.existsSync(abs+e)) { abs = abs+e; break; }
      }
    }

    if (!fs.existsSync(abs)) return line;

    let rel = path.relative(path.join(projectRoot,'client','src'), abs).replace(/\\/g,'/');
    for (const e of ['.ts','.tsx','.js','.jsx','.mjs','.mts','.cjs']) {
      if (rel.endsWith(e)) rel = rel.slice(0,-e.length);
    }
    if (rel.endsWith('/index')) rel = rel.slice(0,-('/index'.length));

    if (!keys.has(rel)) return line; // only rewrite if this module_key is in conflict set

    const alias = candidateAliasForKey(rel);
    touched = true;
    return m[1] + m[2] + alias + m[2] + m[4];
  });

  if (touched) {
    fs.writeFileSync(file, newLines.join('\n'));
    changedFiles++;
    console.log('Rewrote imports in', path.relative(projectRoot, file));
  }
}

console.log(`Done. Files changed: ${changedFiles}`);
EOF

echo
echo "To auto-fix the conflicts now, run:"
echo "node $REPORT_DIR/apply-fixes.mjs"

# 5) Rebuild with sourcemap+no-minify (temporary) to verify
# If your config is locked, skip changing vite.config and still rebuild:
echo
echo "Rebuilding (normal)‚Ä¶"
node scripts/inject-build-env.mjs && npm run build


After it runs:

If conflicts.json shows entries, run:

node tools/import-scan/apply-fixes.mjs
node scripts/inject-build-env.mjs && npm run build


Launch the app and confirm there‚Äôs no ReferenceError: Cannot access 'c' before initialization.
If anything persists, copy the top 2‚Äì3 stack frames (with file names/lines). With that, I can point to the exact import causing it.

If you hit ‚Äúvite config locked‚Äù again, this workflow is still fine‚Äîby normalizing imports repo-wide, you remove the duplication risk even without vite-tsconfig-paths.