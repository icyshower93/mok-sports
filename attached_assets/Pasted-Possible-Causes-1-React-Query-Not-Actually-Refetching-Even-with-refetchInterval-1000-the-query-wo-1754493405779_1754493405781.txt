Possible Causes
1. React Query Not Actually Refetching
Even with refetchInterval: 1000, the query won’t fire if:

The tab is inactive (by default, React Query pauses refetching on background tabs).

You're using React Query v5 with custom behavior options that override refetch behavior.

✅ Solution:
Add this to your query or React Query provider:

ts
Copy
Edit
// In query config
refetchIntervalInBackground: true,
Or globally:

tsx
Copy
Edit
<QueryClientProvider
  client={new QueryClient({
    defaultOptions: {
      queries: {
        refetchIntervalInBackground: true,
      },
    },
  })}
>
2. You're Still Logging Old Local State
Ensure your logging statement is pulling directly from data, not from some useState() or useEffect() copy.

❌ Bad:
tsx
Copy
Edit
const [localTime, setLocalTime] = useState(0);
useEffect(() => {
  setLocalTime(data?.state?.timeRemaining ?? 0);
  console.log("Server Time:", localTime); // ← logs stale value
}, [data]);
✅ Good:
tsx
Copy
Edit
console.log("Server Time:", data?.state?.timeRemaining); // ← logs real-time server value
3. The fetchDraft() Function Is Returning Cached or Static Data
Check what fetchDraft() is doing. It must not:

Read from a global variable.

Return a static mocked object.

Cache the response internally.

✅ fetchDraft() should look like:
ts
Copy
Edit
const fetchDraft = async (draftId: string) => {
  const res = await fetch(`/api/drafts/${draftId}`);
  if (!res.ok) throw new Error("Network error");
  return res.json();
};
Also log:

ts
Copy
Edit
const res = await fetch(`/api/drafts/${draftId}`);
console.log("Fetched response:", await res.clone().text());
return res.json();
4. Mismatched draftId in URL vs Query Key
If the draftId from the route or props isn't ready yet, the query may:

Not fire

Fire with undefined ID

Never refetch again

✅ Add this to your hook:
ts
Copy
Edit
enabled: !!draftId, // ← prevents firing until ID is ready
Also log draftId before useQuery():

ts
Copy
Edit
console.log("Using draftId:", draftId);
5. React Strict Mode or Dev Behavior Doubling Effects
React 18 dev mode may double call effects or render logic. That sometimes leads to timing bugs if state is improperly derived.

✅ You're probably okay if you're now using data?.state?.timeRemaining.

Still, if using any useEffect() to update local state, just remove it. Rely entirely on data.

6. The Component Isn’t Re-rendering on Query Update
This can happen if:

The query key is incorrectly memoized (e.g., missing dependencies)

The component rendering timeRemaining is wrapped in React.memo() or has shouldComponentUpdate preventing updates

✅ Test:
Force a rerender on data change:

tsx
Copy
Edit
useEffect(() => {
  console.log("Refetched timeRemaining:", data?.state?.timeRemaining);
}, [data?.state?.timeRemaining]);
If this never logs — the component isn’t re-rendering when data updates.

7. You’re on React Query v5, but Using v4 Syntax Somewhere
Ensure you’re not using old config like cacheTime, which no longer works in v5.

✅ You did this correctly:

gcTime instead of cacheTime

Still, confirm React Query version in package.json:

json
Copy
Edit
"@tanstack/react-query": "^5.0.0"
8. Server-Side Cache (Replit or Proxy)
Sometimes Replit or Vite preview proxies aggressively cache GET requests.

✅ Add a cache-busting header:

ts
Copy
Edit
const fetchDraft = async (draftId: string) => {
  const res = await fetch(`/api/drafts/${draftId}`, {
    headers: {
      'Cache-Control': 'no-cache',
    },
  });
  return res.json();
};
