What the logs reveal (in plain English)

“Start Draft” fires twice
You see two lines:
[StartDraft] ✅ Starting draft for league: … (twice) → the click handler runs twice (double-click/StrictMode remount). You need a simple starting guard and/or ignore if league.draftId already exists.

Waiting room opens the draft socket
use-draft-websocket.ts:48 [WS] Connected to draft: … before you navigate → the waiting room is grabbing the draft WS. That competes with the draft page and causes churn.

WebSocket keeps closing 1000 and reconnecting
Repeated Connection closed: 1000 is almost always caused by your hook re-running on every render because you passed a { onDraftState, onTimerUpdate } object that changes identity each render. Your effect depends on that, so it closes (1000) and re-opens over and over.

Draft state updated: undefined
Your message parser assumes the server sends { type, payload }. Sometimes it’s { type, data } or { draft }. You’re swallowing real state.

All four are easy, small fixes. No overengineering. Here’s the minimal patch set.

1) Make the WS hook stable (no reopen on each render)

client/src/hooks/use-draft-websocket.ts – drop-in replacement:

import { useEffect, useRef, useState } from "react";
import { wsUrl } from "@/lib/endpoints";

type Callbacks = {
  onDraftState?(state: any): void;
  onTimerUpdate?(t: { display: number }): void;
};

function decodeMessage(raw: any) {
  let msg: any = raw;
  if (typeof raw === "string") {
    try { msg = JSON.parse(raw); } catch { /* non-JSON like "connected" */ }
  }
  return msg;
}

function pickDraftState(msg: any) {
  // tolerate a few shapes
  if (!msg) return undefined;
  if (msg.payload) return msg.payload;
  if (msg.data) return msg.data;
  if (msg.state) return msg.state;
  if (msg.draft) return msg.draft;
  return undefined;
}

export function useDraftWebSocket(
  draftId: string | null | undefined,
  userId: string | null | undefined,
  callbacks?: Callbacks
) {
  const socketRef = useRef<WebSocket | null>(null);
  const reconnectTimerRef = useRef<number | null>(null);
  const cbsRef = useRef<Callbacks | undefined>(callbacks);
  const [reconnectTick, setReconnectTick] = useState(0);

  // keep callbacks in a ref so they don't retrigger the effect
  useEffect(() => { cbsRef.current = callbacks; }, [callbacks]);

  const clearReconnect = () => {
    if (reconnectTimerRef.current) {
      clearTimeout(reconnectTimerRef.current);
      reconnectTimerRef.current = null;
    }
  };

  useEffect(() => {
    if (!draftId || !userId) return;
    if (socketRef.current) return;

    const url = wsUrl("/draft-ws", { draftId, userId });
    const ws = new WebSocket(url);
    socketRef.current = ws;

    ws.onopen = () => {
      // console.log("[WS] open", url);
      clearReconnect();
    };

    ws.onmessage = (ev) => {
      const msg = decodeMessage(ev.data);
      if (!msg || typeof msg === "string") return; // "connected", etc.
      if (msg.type === "draft_state") {
        const state = pickDraftState(msg);
        cbsRef.current?.onDraftState?.(state);
      } else if (msg.type === "timer_update") {
        const t = pickDraftState(msg) ?? msg; // some servers send the object directly
        if (t && typeof t.display !== "undefined") {
          cbsRef.current?.onTimerUpdate?.(t);
        }
      }
    };

    ws.onerror = () => {
      // console.log("[WS] error");
    };

    ws.onclose = (e) => {
      // console.log("[WS] close", e.code);
      socketRef.current = null;
      if (e.code !== 1000 && !reconnectTimerRef.current) {
        reconnectTimerRef.current = window.setTimeout(() => {
          reconnectTimerRef.current = null;
          setReconnectTick((t) => t + 1);
        }, 1000);
      }
    };

    return () => {
      clearReconnect();
      try { ws.close(1000, "cleanup"); } catch {}
      socketRef.current = null;
    };
    // Only the identifiers + reconnect tick matter here.
    // DO NOT include callbacks in deps.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [draftId, userId, reconnectTick]);
}


Uses a callbacks ref so re-renders don’t tear down the socket.

Accepts varied message shapes, so onDraftState won’t get undefined when valid state arrives.