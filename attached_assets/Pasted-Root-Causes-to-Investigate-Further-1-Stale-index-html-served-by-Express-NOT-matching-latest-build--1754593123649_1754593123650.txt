Root Causes to Investigate Further
1. Stale index.html served by Express (NOT matching latest build)
If you're doing something like this in your server:

ts
Copy
Edit
app.use(express.static('dist/public'))
app.get('*', (req, res) => {
  res.sendFile(path.resolve(__dirname, 'dist', 'public', 'index.html'))
})
The index.html may still point to the old hash (index-DXM0lNw6.js) unless itâ€™s overwritten or loaded fresh every time.

ğŸ” Confirm: Does the contents of dist/public/index.html include the correct <script src="/assets/index-CC1wKwhx.js">?

If yes, the problem is in filesystem persistence.
If no, your build isnâ€™t fully updating the HTML or the server isnâ€™t pointing to the right one.

2. Replit Filesystem Bug or Reversion on Restart
Sometimes Replit containers donâ€™t persist file system changes fully, or they restore from a cached snapshot when restarted.

ğŸ” Check: After rebuild and restart, run this:

bash
Copy
Edit
grep index- dist/public/index.html
ls dist/public/assets/index-*.js
Do these match? If not, Replit is reverting to stale assets or thereâ€™s a startup build mismatch.

3. Service Worker Interference
Even after a hard refresh, a rogue service worker could:

Serve old JS bundles from cache

Prevent index.html updates

Cause random white screen issues

âœ… In dev, you might want to unregister SWs aggressively:

ts
Copy
Edit
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(regs => {
    for (let reg of regs) reg.unregister();
  });
}
4. Browser Requests Old Hashed JS Due to HTML Cache
Check whether:

index.html is being cached and re-served (e.g., with Cache-Control: max-age=3600)

Your browser loads a previously fetched index that references an old chunk

ğŸ›  Fix Plan (Quick + Thorough)
âœ… 1. Force index.html and JS sync
bash
Copy
Edit
# Fully clean up
rm -rf dist/public/assets
rm -f dist/public/index.html

# Rebuild frontend
npm run build

# Confirm correct linkage
grep index- dist/public/index.html
ls dist/public/assets/index-*.js
If the script tag in index.html doesnâ€™t match the actual JS file, you have a build problem. If it does, you're clean â€” just move to the next step.

âœ… 2. Serve from fresh memory (bypass Replit FS caching)
Modify your server to dynamically read index.html at runtime, not from memory:

ts
Copy
Edit
app.get('*', (req, res) => {
  const indexPath = path.join(__dirname, 'dist/public/index.html')
  fs.readFile(indexPath, 'utf8', (err, data) => {
    if (err) return res.status(500).send('Error loading index')
    res.send(data)
  })
})
ğŸ§  This forces it to always read the freshest version on disk.

âœ… 3. Add "no-cache" headers for dev
Set headers on your static asset routes:

ts
Copy
Edit
app.use('/assets', express.static('dist/public/assets', {
  setHeaders: (res) => {
    res.setHeader('Cache-Control', 'no-store')
  }
}))
