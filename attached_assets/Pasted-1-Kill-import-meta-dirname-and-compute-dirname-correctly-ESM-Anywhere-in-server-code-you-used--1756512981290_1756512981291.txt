1) Kill import.meta.dirname and compute __dirname correctly (ESM)

Anywhere in server code you used import.meta.dirname, replace it with this pattern:

// top of your server entry (e.g., server/src/index.ts)
import { fileURLToPath } from 'url';
import path from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);


Node ESM only exposes import.meta.url. import.meta.dirname isn’t a thing and can break in production/bundlers.

2) Make Vite dev integration dev-only (no static ./vite import)

Do not import a ./vite helper at top level. In prod, that module won’t exist (or will pull Vite into your server bundle). Use a conditional dynamic import:

// server/src/index.ts
import express from 'express';
import http from 'http';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);
const isDev = process.env.NODE_ENV !== 'production';

const app = express();
const server = http.createServer(app);

// --- DEV: attach Vite middlewares (no static imports!) ---
if (isDev) {
  const { createServer: createViteServer } = await import('vite');
  const vite = await createViteServer({
    root: path.resolve(process.cwd(), 'client'),
    server: { middlewareMode: true },
    appType: 'spa',
  });
  app.use(vite.middlewares);
} else {
  // --- PROD: serve client built assets ---
  // If compiled to server/dist, this resolves ../../client/dist
  const clientDist = path.resolve(__dirname, '../../client/dist');

  app.use(express.static(clientDist, { maxAge: '1h', index: false }));

  // SPA fallback
  app.get('*', (_req, res) => {
    res.sendFile(path.join(clientDist, 'index.html'));
  });
}

// Health (helps Replit detect readiness)
app.get('/healthz', (_req, res) => res.status(200).send('ok'));

// PORT/HOST for Replit
const PORT = Number(process.env.PORT) || 3000;
const HOST = '0.0.0.0';

server.listen(PORT, HOST, () => {
  console.log(`[server] listening on http://${HOST}:${PORT} (NODE_ENV=${process.env.NODE_ENV || 'undefined'})`);
});

export default app;


If you have your own ./vite.ts helper, export a function and only await import('./vite.js') inside the if (isDev) block. Don’t leave import './vite' at top level.

3) Stop using app.get('env') for environment checks

Express’s app.get('env') is tied to NODE_ENV but can behave oddly depending on how the app is launched. Use a single flag consistently:

const isDev = process.env.NODE_ENV !== 'production';
// replace: if (app.get('env') === 'development') { ... }
// with:
if (isDev) {
  // dev-only logging, error stacks, vite middleware, etc.
}


In Replit, ensure you set NODE_ENV=production for deployments.

4) Package & scripts (root)

Make sure your deployment runs the server build and serves the client build:

{
  "type": "module",
  "scripts": {
    "build:client": "npm --prefix client run build",
    "build:server": "npm --prefix server run build",
    "build": "npm run build:client && npm run build:server",
    "start": "node server/dist/index.js",
    "start:dev": "NODE_ENV=development node --enable-source-maps server/dist/index.js"
  }
}


And inside client/package.json you should already have:

{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview --host"
  }
}


Inside server/package.json:

{
  "type": "module",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "start": "node dist/index.js"
  }
}


Ensure server/tsconfig.json compiles to server/dist and preserves ESM ("module": "esnext") with "moduleResolution": "node" or "bundler".

5) Pathing to client dist after compile

When server/src/index.ts compiles to server/dist/index.js, this relative works:

const clientDist = path.resolve(__dirname, '../../client/dist');


If your build layout differs, override via env:

const clientDist = process.env.CLIENT_DIST ?? path.resolve(__dirname, '../../client/dist');


Set CLIENT_DIST=/app/client/dist if needed.

6) Replit deployment specifics

Ensure your run command for deployment ultimately executes: node server/dist/index.js.

The server must listen on process.env.PORT and 0.0.0.0.

Provide a health endpoint (/healthz) so Replit knows the app is up.

Set NODE_ENV=production in Replit’s environment for deploys.

7) Quick grep checklist (do this in your repo)

Search and fix these:

import.meta.dirname → replace with fileURLToPath pattern.

Top-level import './vite' or import { attachVite } from './vite' → remove; use await import('./vite.js') inside the if (isDev).

if (app.get('env') === 'development') → replace with if (isDev)